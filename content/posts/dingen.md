---
_g_feedback_shortcode_8f6f73bc58f0cd7a5fe1fde1c49c37cd805d10ce: |-
  [contact-field label="Name" type="name"  required="true" /]
  				[contact-field label="Email" type="email" required="true" /]
  				[contact-field label="Website" type="url" /]
  				[contact-field label="Message" type="textarea" /]
_g_feedback_shortcode_atts_8f6f73bc58f0cd7a5fe1fde1c49c37cd805d10ce:
  block_template: null
  block_template_part: null
  className: null
  customThankyou: ""
  customThankyouHeading: Your message has been sent
  customThankyouMessage: Thank you for your submission!
  customThankyouRedirect: ""
  hiddenFields: null
  id: 18041
  jetpackCRM: true
  postToUrl: null
  salesforceData: null
  show_subject: "no"
  stepTransition: fade-slide
  subject: '[alper.nl] `Paper:'
  submit_button_text: Submit
  to: alper@alper.nl
  widget: 0
author: alper
categories:
  - english
date: "2025-02-08T11:08:00+00:00"
draft: "true"
guid: https://alper.nl/dingen/?p=18041
parent_post_id: null
post_id: "18041"
title: '`Paper:'
url: /dingen/

---
[How is Google using AI for internal code migrations?](https://arxiv.org/pdf/2501.06972)

\> Second is bespoke solutions for each PA. Examples include specific code migrations, code efficiency optimization, and test generation tasks, where we have effectively used LLMs in custom (or “bespoke”) ways.

\> The measure of success we adopt is whether there is at least a 50% acceleration in task completion rate in an ongoing project

\> we have been able to complete complex migrations that were stalled for several years and required continued attention from the business. We have completed efforts that spanned several teams using a handful of engineers and saved the business hundreds of engineers worth of work.

\> While developers still need to spend time reviewing suggestions, they have more time to focus on code design.

DIDACT: Petros Maniatis and Daniel Tarlow. Large sequence

models for software development activities. 2023. URL: https : / / research . google / blog / large - sequence - models - for-software-development-activities/

\> This is because the contextual clues and the actual changes to be made have quite a bit of variance, and these are difficult to write out in a deterministic code transformation pass.

\> The full effort, if done manually was expected to require hundreds of software engineering years and complex cross- team coordination.

\> There was also a significant reduction in communication overhead, as a single engineer could generate all necessary changes.

Kythe \[16\] Kythe. URL: https://kythe.io/.

\> The toolkit is versatile and can be used for code migrations with varying requirements and outputs.

\> The edit generation and validation step is where we have found the most benefit from an ML-based approach.

pass@k Mark Chen et al. Evaluating Large Language Models Trained on Code. 2021. arXiv: 2107.03374 \[cs.LG\]. URL: https://arxiv.org/abs/2107.03374.

\> The two most common validations are building the changed files and running their unit tests. Each of the failed validation steps can optionally run an ML-powered “repair”.

Large Scale ChangesT. Winters, T. Manshreck, and H. Wright. Software Engineering at Google: Lessons Learned from Pro- gramming Over Time. O’Reilly Media, 2020. ISBN: 9781492082767. URL: https://books.google.de/books? id=V3TTDwAAQBAJ.

\> With this technique we were able to migrate 5,359 files modifying more than 149,000 lines of code in 3 months. The bottleneck in the process was the speed at which engineers could review the changes.

\> At the end of the migration ∼87% of the code generated by AI ended up committed without any change.

\> We need answers to several questions:

\> 1) Which files should be migrated together?

\> 2) What is the fan-in/out of the call graph? A widely im- plemented interface might lead to a change in hundreds of files.

\> 3) Do the calls ‘escape’ the current component scope we have set for the set of changes? If yes, we might have to create transition wrappers to avoid ‘spreading’ the interface change outside.

\> Gemini has seen enough Joda and java.time code during its training that we don’t actually have to explain what they are. It was able to correctly use the right APIs and didn’t hallucinate wrong parameters or data structures.

Guice Guice. 2025. URL: https://github.com/google/guice/

\> The experimentation engine tracks all experiments and flags across Google and can list all the stale flags - defined as flags whose value has not changed over a long period of time.

\> Unfinished migrations tend to continuously slow down teams even if they are not working directly on them, they confuse new developers with obsolete patterns, and require additional cognitive load. Landing migrations faster has a wide reaching benefits beyond the actual technical code change.

\> Assisting the human developers in the tasks adjacent to the actual code changes in a migration is an area we are actively exploring.

\> The use of generative AI widely, with bespoke techniques, comes with a hidden cost: that of having to train a number of engineers in the use of these techniques. Building elaborate tooling to completely hide the use of AI behind tools is expensive, and it creates a technical obligation to now maintain that tooling, which is used by a relatively small number of engineers.
